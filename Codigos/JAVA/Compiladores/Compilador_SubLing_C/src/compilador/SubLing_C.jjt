/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  STATIC = false;
  DEBUG_PARSER = true;
  DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(SubLing_C)
package compilador;
import java.io.*;
import recovery.*;
import semanAnalysis.*;


public class SubLing_C
{
  // contador de erros sintáticos
  int contParseError = 0;
  //controla verbose de recuperação de erros
  boolean debug_recovery; 
  
  public static void main(String args []) throws ParseException
  {
    boolean debug_as = false;
    boolean debug_recovery = false;

	//nome do arquivo a ser lido
    String filename = "";
    //analisador lexico e sintatico
    SubLing_C parser; 
    int i;
    boolean ms = false;

//lê os parâmetros passados para o compilador
    for ( i = 0; i < args.length-1; i++) {
		if(args[i].equals("-debug_AS")) {
		  debug_as = true;
		  break;
		}else {
		  System.out.println("Usage is: " + "java SubLing_C [-degub_AS] inputfile");
		  System.exit(0);
		}
    }

//lê da entrada padrão
	if(args[i].equals("-")) { 
		 System.out.println("Reading from standard input...");
		 parser = new SubLing_C(System.in); //cria o analisador sintático
		 
	}else {
	  // lê do arquivo
	   filename = args[args.length-1];
	   System.out.println("Reading from file " + filename + ". . .");
	   
	   try {
	     // cria o analisador sintático
	     parser = new SubLing_C(new java.io.FileInputStream(filename));
	     
	   } catch (java.io.FileNotFoundException e) {
	     System.out.println("File " + filename + " not found.");
	     return;
	   }catch (IOException e) {
	     System.out.println("Erro ao abrir o aquivo." + e.getMessage());
	     return;
	   }
	 }

	parser.debug_recovery = debug_recovery;
	if(!debug_as) parser.disable_tracing(); //desabilita verbose do Analisador sintático

	SimpleNode root = null;
	
	try {
	  root = parser.program(); //chama o método que faz a análise
	}catch(ParseException e) {
	  System.err.println(e.getMessage()); 
	}
	  SimpleNode print = root;
	  print.dumpToFile(filename); //imprime a arvore no arquivo
	  Semantic parserSem = new Semantic();
	  
	  
	try { 
	  parserSem.programCheck(root);
	
	}catch(SemanticException e) {
	  System.err.println(e.getMessage());
	}
	
	finally {
	  
	  System.out.println(parser.token_source.foundLexError() + " Lexical Errors found");
	  System.out.println(parser.contParseError + " Syntactic Errors found");
	  System.out.println(parserSem.getFoundSemanticError() + " Semantic Erros found");
	}
  }//main

  static public String im  (int x) {
    int k;
    String s;

    s = tokenImage[x];
    k = s.lastIndexOf("\"");

    try { s = s.substring(1,k); }
    catch (StringIndexOutOfBoundsException e) { }
    return s;
  }

  boolean eof; //variável que indica se EOF foi alcançado
 

/**
* consumeUntil, consome tokenns até alcançar um que pertença ao conjunto de sincronização
* @param g, conjunto de sincronização que será usado
* @param e, descreve o erro sintático que ocorreu
* @oaram met, não terminal que faz a recuperação dos erros
* @pre-condition nenhuma
* @post-condition nenhuma
*/
 void consumeUntil(RecoverySet g, ParseException e, String met) throws /*/*ParseEOFException*/ ParseException{
 	Token tok;
 		if(debug_recovery){ //informa sobre a recuperação
 			System.out.println();
 			System.out.println("*** " + met+ "***");
 			System.out.println("	Syncronizing Set: " + g);
 		}
 		if(g == null) throw e; // se o conjunto é nulo, propaga a exceção

 		tok = getToken(1); //pega token corrente
 		while(!eof){ //se não chegou ao fim do arquivo
 			if(g.contains(tok.kind)) { //acha um token no conjunto
 				if(debug_recovery){
 					System.out.println("	found Syncronizing token: " + im(tok.kind));
 					break;
 				}
 			}
 			if(debug_recovery){
 					System.out.println("	ignoring token: " + im(tok.kind));
 			}
 			getNextToken(); 
 			tok = getToken(1);
 			if(tok.kind == EOF && !g.contains(EOF)) eof = true;
 		}
 		System.out.println(e.getMessage());
 		contParseError++;
 		//if(eof) throw new /*ParseEOFException*/("EOF found prematurely.");
 }
}//SubLing_C

PARSER_END(SubLing_C)

/**
* TOKEN_MGR_DECLS, Introduz código java na classe correspondente ao analisador léxico
* @pre-condition nenhuma
* @post-condition nenhuma
* @return número de erro lexico encontrado no arquivo que está sendo analisado
*/
TOKEN_MGR_DECLS : {
	int countLexError= 0;

	public int foundLexError() {
		return countLexError;
	}
}

/**
* SKIP, Define quais cadeias deverão ser ignoradas e não vão entrar no reconhecimento de token 
* @pre-condition nenhuma
* @post-condition nenhuma
*/
SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

/**
* TOKEN, Define conjunto de operadores a serem reconhecidos
* @pre-condition nenhuma
* @post-condition nenhuma
*/
TOKEN : /* OPERATORS */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < AND : "&&" >
| < OR : "||" >
| < NOT : "!" >
| < ASSIGNMENT : "=" >
| < ASSIGNMENT_PLUS : "+=" >
| < ASSIGNMENT_MINUS : "-=" >
| < ASSIGNMENT_MULTIPLY : "*=" >
| < ASSIGNMENT_DIVIDE : "/=" >
| < GT : ">" >
| < LT : "<" >
| < GE : ">=" >
| < LE : "<=" >
| < EQ : "==" >
| < NEQ : "!=" >
}

/**
* TOKEN, define conjunto de palavras reservadas a serem reconhecidas e as expressões que as define são as próprias palavras
* @pre-condition nenhuma
* @post-condition nenhuma
*/
TOKEN : /*PALAVRA RESERVADA*/
{
  < INT : "int" >
| < CHAR : "char" >
| < IF : "if" >
| < ELSE : "else" >
| < SWITCH : "switch" >
| < CASE : "case" >
| < BREAK : "break" >
| < FOR : "for" >
| < WHILE : "while" >
| < VOID : "void" >
| < RETURN : "return" >
| < DEFAULTT : "default" >
}

/**
* TOKEN, define conjunto de símbolos especiais a serem reconhecidos
* @pre-condition nenhuma
* @post-condition nenhuma
*/
TOKEN : /*SIMBOLOS ESPECIAIS*/
{
  < L_PAREN : "(" >
| < R_PAREN : ")" >
| < L_CHAV : "[" >
| < R_CHAV : "]" >
| < L_COLC : "{" >
| < R_COLC : "}" >
| < PONT_VIRG : ";" >
| < TWO_PONT : ":" >
| < VIRG : "," >
}

/**
* TOKEN, define conjunto de constantes a serem reconhecidas
* @pre-condition nenhuma
* @post-condition nenhuma
*/ 
TOKEN : /*CONSTANTES*/
{
  // constantes números
  < INT_CONSTANT : (< DIGIT >)+ >

  // constantes string 
| < CHAR_CONSTANT : "\""( ~["\"","\n","\r"])* "\"" >
| < NULL_CONSTANT : "null" >
| < #DIGIT : [ "0"-"9" ] >
| < #CARACTERES : ["A" - "Z","a"-"z"] >
}

/**
* TOKEN, define conjunto de identificadores a serem reconhecidos
* @pre-condition nenhuma
* @post-condition nenhuma
*/ 
TOKEN : /*IDENTIFICADORES*/
{
  < IDENT : < CARACTERES > (< CARACTERES > | < DIGIT >)* >
}

/**
* SPECIAL_TOKEN, trata os erros léxicos, significa que não é passado para o analisador léxico mas é armazenado
* @var ~, indica que o casamento é feito quando os caracter  de entrada não está no conjunto definido entre os colchetes
* @var +, indica que a repetição ocorrerá pelo menos uma vez
* @pre-condition nenhuma
* @post-condition nenhuma
*/ 
SPECIAL_TOKEN : /*TRATA OS ERROS LEXICOS*/
{
  < INVALID_LEXICAL :
  (
    ~["a"-"z" , "A"-"Z",
    "0"-"9",
    "\"",
    "(", ")",
    "[", "]",
    "{", "}",
    ";", ":", ",",
    ">", "<",
    "=", "!",
    "+", "-", "*", "/",
    " ", "\t", "\n", "\r"]
  )+ >
	{
	  System.err.println("Line " + input_stream.getEndLine() + " - Invalid string found: " + image);
	  countLexError++;
	}
}

/**
* program, É um não-terminal que após reconhecer o functlist na entrada, ele tenta achar o EOF,
* @pre-condition: nenhuma
* @post-condition: se não conseguir achar o EOF deverá fazer a ressincronização e voltar a analisar o programa
*/ 
SimpleNode program() #PROGRAMA: {
	RecoverySet g = First.program;
}
{
 (
    < EOF > |  functlist(g)
	try{
		< EOF > 
	}catch(ParseException e){
		consumeUntil(g, e, "program");
	}
	[program()]
) { return jjtThis; }
}

/**
* functlist, é um não terminal que diz que o programa é formado por uma lista de funções, seguido pelo EOF
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: o erro é tratado 
*/
void functlist(RecoverySet g) #FUNCT_LIST: {
	RecoverySet f = First.functlist.union(g);
}
{
  (
   // functdecl passa como conjunto de sincronização o conjunto g que foi passado como parametro
  // após functdecl, o functlist pode ou não ocorrer  
  functdecl(f) [functlist(g)]
) 
}

/**
* functdecl, define como formar a assinatura da função
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: 
*/ 
void functdecl(RecoverySet g) #FUNCT_DECL: { //assinatura da função
	RecoverySet f = new RecoverySet (R_PAREN);
	RecoverySet h = new RecoverySet (IDENT);
	Token t;
}
{
  try { 
		functype(h) t = <IDENT>  <L_PAREN> paramlist(f) < R_PAREN >  < L_COLC > functbody(g) < R_COLC >
		{if(t != null)jjtn000.value1 = t.image; }
		  
	}catch (ParseException e) {
	  consumeUntil(g, e, "functdecl");
	}
}


/**
* paramlist, define como formar a lista de parâmetros
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void paramlist(RecoverySet g) #PARAM_LIST: { // lista de parametros
	RecoverySet f = new RecoverySet (IDENT);
	Token t1 = null, t2 = null;
}
{
  try { 
  	[functype(f) t1 = <IDENT> (< L_CHAV > <R_CHAV >)* (< VIRG > functype(f) t2 = <IDENT > (< L_CHAV ><R_CHAV >)*)*]
	{
	  if(t1 != null) {
	    jjtn000.value1 = t1.image;
	    if(t2 != null) {
	      jjtn000.value2 = t2.image;
	    }
	  }
	}
  }catch(ParseException e) {
    consumeUntil(g, e, "paramlist");
  }
}

/**
* varlist, demonstra como declarar uma variável
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void varlist(RecoverySet g) #VAR_LIST: { //declaração de variavel
	Token nome = null, tipo = null;
}
{
  	try { 
    	(tipo = < VOID > | tipo = < INT > | tipo = < CHAR > )
    	nome = <IDENT> (< L_CHAV >(<INT_CONSTANT>)+<R_CHAV >)*
    	{
    	  if(nome != null) { 
    		jjtn000.value1 = tipo.image;
    		}if(tipo != null) { 
    			jjtn000.value2 = nome.image;
			}
    	}
   }catch(ParseException e) {
     consumeUntil (g, e, "varlist");
   }
}

/**
* functype, define qual será o tipo das variáveis
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: tipo da variável é definido
*/
void functype(RecoverySet g) #FUNCT_TYPE : { //tipos de variaveis
	Token tipo = null;
} 
{
  try { 
  	tipo = < VOID > | tipo =  < INT > | tipo = < CHAR > | tipo = < IDENT >
  	{if(tipo != null) jjtn000.value1 = tipo.image; }
 }catch(ParseException e) {
   consumeUntil (g, e, "functype");
 }
}

/**
* functbody, define como será definido o corpo do função
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: corpo da função é definido
*/ 
void functbody(RecoverySet g) #FUNCT_BODY: {
	RecoverySet f = new RecoverySet(PONT_VIRG);
}
{
try {  	
  	(
  	varlist(f) <PONT_VIRG>
|	comand_if(g)
|	comand_switch(g)
| 	comand_for(g)
| 	comand_while(g)
| 	atrib(f) < PONT_VIRG >
| 	< BREAK > <PONT_VIRG >
| 	Return(f)< PONT_VIRG >
	)*
	}catch(ParseException e) {
		consumeUntil (g, e, "functbody");
	}
}

/**
* return, define como o comando "return" funcionará
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void Return(RecoverySet g) #RETURN : { }
{
  try { 
  	< RETURN > expressao(g)
 }catch(ParseException e) {
   consumeUntil (g, e, "Return");
 }
}

/**
* comand_if, define como o comando "if" funcionará
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void comand_if(RecoverySet g) #IF: {
	RecoverySet f1 = new RecoverySet(R_PAREN), f2 = new RecoverySet(ELSE).union(g);
}
{
  try { 
  	< IF > <L_PAREN > expressao(f1) < R_PAREN > <L_COLC> functbody(f2) <R_COLC> [< ELSE > <L_COLC>functbody(g)<R_COLC>]
 }catch(ParseException e) {
	consumeUntil(g, e, "comand_if");
 }
}

/**
* comand_switch, define como o comando "switch" funcionará 
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void comand_switch(RecoverySet g) #SWITCH: {
	RecoverySet f = new RecoverySet(PONT_VIRG);
	Token t;
}
{
  try { 
	  < SWITCH > < L_PAREN > t = < IDENT > < R_PAREN > <L_COLC >
	  (
	    < CASE > (< INT_CONSTANT > | < CHAR_CONSTANT >) < TWO_PONT >
		(atrib(f)<PONT_VIRG >)+
	  < BREAK > <PONT_VIRG >
	  )+
	  < DEFAULTT > < TWO_PONT >(atrib(f) < PONT_VIRG >)+
	  < R_COLC >
	  {  jjtn000.value1 = t.image; }
	}catch(ParseException e) {
	  consumeUntil(g, e, "comand_switch");
	}
}

/**
* comand_for, define como o comando "for" funcionará
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: nenhuma 
*/ 
void comand_for(RecoverySet g) #FOR : {
	RecoverySet f1 = new RecoverySet(PONT_VIRG), f2 = new RecoverySet(R_COLC);
}
{
  try { 
		<FOR> <L_PAREN> [atrib(f1)] <PONT_VIRG>
						[expressao(f1)] <PONT_VIRG>
						[atrib(f2)] <R_PAREN>
		<L_COLC> functbody(g) <R_COLC>
	}catch(ParseException e) {
	  consumeUntil(g, e, "comand_for");
	}
}

/**
* comand_while, define como o comando "while" funcionará
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void comand_while(RecoverySet g) #WHILE: {
	RecoverySet f = new RecoverySet(R_PAREN);
}
{
  try { 
		<WHILE> <L_PAREN> expressao(f) <R_PAREN>
		<L_COLC> functbody(g) <R_COLC>
	}catch(ParseException e) {
		consumeUntil(g, e, "comand_while");
	}
}

/**
* atrib, faz atribuição, uma variável que recebe alguma expressão
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/
void atrib(RecoverySet g) #ATRIBUICAO: {
	Token id = null;
  }
{
  try { 
	( id = < IDENT > )( < ASSIGNMENT > | < ASSIGNMENT_PLUS > | < ASSIGNMENT_MINUS > | < ASSIGNMENT_MULTIPLY > | < ASSIGNMENT_DIVIDE >) expressao(g)
	{	if(id != null) jjtn000.value1 = id.image; }
	}catch(ParseException e) {
	  consumeUntil(g, e, "atrib");
	} 
}

/**
* expressao, monta as expressões matemáticas e booleanas
* @param g, nome do conjunto de tokens de sincronização
* @pre-condition: nenhuma
* @post-condition: expressões matemática e booleanas são formadas
*/
void expressao(RecoverySet g) #EXPRESSAO: {
	Token op = null;
}
{
  try { 
	numexpr()
	[(op =  < LT >
	| op = < GT >
	| op = < LE >
	| op = < GE >
	| op = < EQ >
	| op = < NEQ >
	| op = < AND >
	| op = < OR >)
	numexpr()]
	{if(op != null) jjtn000.k = op;}
	}catch(ParseException e) {
	  consumeUntil(g, e, "expressao");
	}
}

/**
* numexpr, indica a ação de soma e subtração
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void numexpr() #NUMERO_EXPRESSAO: {
	Token operador = null;
}
{
	term() ((operador = < PLUS > | operador = < MINUS >) term())*
	{if(operador != null) jjtn000.value1 = operador.image; }
}

/**
* term, indica a ação de multiplicação e divisão
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void term() #TERM : {
  Token operador = null;
}
{
	unaryexpr() ((operador = < MULTIPLY > | operador = < DIVIDE >) unaryexpr())*
	{if(operador != null) jjtn000.value1 = operador.image; }
}

/**
* unaryexpr, indica se o número é positivo ou negativo
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/
void unaryexpr() #UNARY_EXPR: {
  Token operador = null;
}
{
	[(operador = < PLUS > | operador = < MINUS >)] factor()
	{
		if(operador != null) jjtn000.k = operador; 
		else jjtn000.value1 = "Null";
	}
}

/**
* factor, garate que a divisão seja feita por primeiro
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/
void factor() #FACTOR: {
	Token operador = null;
	Token not = null;
}
{
	[not = < NOT >](operador =  < INT_CONSTANT > |  operador = < CHAR_CONSTANT > |  operador = < NULL_CONSTANT > | operador = < IDENT > | operador = < L_PAREN > expressao(null) < R_PAREN >)
	{
		if(not != null)jjtn000.k = not;
		else jjtn000.value1 = "Null";
		if(operador != null)jjtn000.k = operador;
	  }
}